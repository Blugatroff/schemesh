;;; Copyright (C) 2023-2024 by Massimiliano Ghilardi
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.


(library (schemesh lineedit paren (0 1))
  (export
    make-paren    paren?   paren-name paren-token
    paren-ok?     paren-ok?-set!   paren-recursive-ok?
    paren-start-x paren-start-y    paren-start-xy-set!
    paren-end-x   paren-end-y      paren-end-xy-set!
    paren-valid?  paren-inner      paren-inner-empty?  paren-inner-append!
    paren->values paren->hashtable paren-hashtable-ref

    is-paren-char? debugf-paren)
  (import
    (rnrs)
    (rnrs mutable-pairs)
    (only (chezscheme) format fx1+ fx1- record-writer unread-char void)
    (only (schemesh bootstrap) assert* catch debugf try until while)
    (only (schemesh containers misc) list-iterate)
    (only (schemesh containers hashtable) hashtable-iterate)
    (schemesh containers span)
    (schemesh containers charspan))


;; paren is an object containing information about the matching parentheses/brackets/braces/quotes
;; in some text to be parsed
(define-record-type
  (paren %make-paren paren?)
  (fields
    name  ; symbol, name of parser that created this paren object (may differ in sub-objects)
    token ; character, one of: # ( [ { " ' ` |
    (mutable ok?)     ; boolean, #t if matching parenthesis/bracket/brace/quote found
    (mutable start-x) ; fixnum, x position of start parenthesis/bracket/brace/quote
    (mutable start-y) ; fixnum, y position of start parenthesis/bracket/brace/quote
    (mutable end-x)   ; fixnum, x position of end parenthesis/bracket/brace/quote
    (mutable end-y)   ; fixnum, y position of end parenthesis/bracket/brace/quote
    (mutable inner))  ; #f or span of nested paren appearing between start and end
  (nongenerative #{paren e1s38b5dr3myvj5mwxrpzkl27-400}))


(define (make-paren name token)
  (assert* 'make-paren (symbol? name))
  (when token
    (assert* 'make-paren (char? token)))
  (%make-paren name token #f 0 0 (greatest-fixnum) (greatest-fixnum) #f))


;; return #t if paren' token is truish, ok? is #t, both start and end positions of paren are valid
(define (paren-valid? paren)
  (and (paren? paren) (paren-token paren) (paren-ok? paren)
    (let ((start-xy (xy->key (paren-start-x paren) (paren-start-y paren)))
          (end-xy   (xy->key (paren-end-x paren)   (paren-end-y paren))))
      (fx<? -1 start-xy end-xy))))

;; return #t if (paren-ok?) is true in paren and in all its inner paren.
(define (paren-recursive-ok? paren)
  (and paren (paren-ok? paren)
       (let* ((inner (paren-inner paren))
              (n (if (span? inner) (span-length inner) 0)))
         (do ((i 0 (fx1+ i)))
             ((or (fx>=? i n) (not (paren-recursive-ok? (span-ref inner i))))
              (fx>=? i n))))))

(define (paren-inner-empty? paren)
  (let ((inner (paren-inner paren)))
    (if (span? inner)
      (span-empty? inner)
      #t)))

;; append one nested paren to specified paren
(define (paren-inner-append! paren nested-paren)
  (when (and paren nested-paren)
    (assert* 'paren-inner-append! (paren? paren))
    (assert* 'paren-inner-append! (paren? nested-paren))
    (let ((inner (paren-inner paren)))
      (if (span? inner)
        (span-insert-back! inner nested-paren)
        (paren-inner-set! paren (span nested-paren))))))

;; traverse paren and convert it to a hashtable (+ x (* y 65536)) -> paren
(define (paren->hashtable paren)
  ;; (debugf "(paren->hashtable ~s)~%" paren)
  (if paren
    (%paren->hashtable paren (make-eqv-hashtable))
    #f))

;; traverse paren and convert it to a hashtable (+ x (* y 65536)) -> paren
(define (%paren->hashtable paren htable)
  ;; (debugf "(%paren->hashtable ~s)~%" paren)
  (when (paren-valid? paren)
    (%hashtable-put-paren htable paren))
  (let ((inner-span (paren-inner paren)))
    (when inner-span
      (span-iterate inner-span
        (lambda (i inner)
          (%paren->hashtable inner htable)))))
  htable)

;; add paren to hashtable, using both positions start-x start-y and end-x end-y
(define (%hashtable-put-paren htable paren)
  (hashtable-set! htable (xy->key (paren-start-x paren) (paren-start-y paren)) paren)
  (hashtable-set! htable (xy->key (paren-end-x paren)   (paren-end-y paren))   paren)
  htable)

(define (paren-start-xy-set! paren x y)
  (paren-start-x-set! paren x)
  (paren-start-y-set! paren y))

(define (paren-end-xy-set! paren x y)
  (paren-end-x-set! paren x)
  (paren-end-y-set! paren y))

(define (xy->key x y)
  (if (and (fx<=? 0 x 65535) (fx<=? 0 y 65535))
    (fxior x (fxarithmetic-shift-left y 16)) ; optimized version of (+ x (* y 65536))
    -1))

;; search in hashtable generated by (paren->hashtable) and return paren matching x y, or #f
(define (paren-hashtable-ref htable x y)
  (hashtable-ref htable (xy->key x y) #f))


;; extract fields name token start-x start-y end-x end-y from paren and return them
(define (paren->values paren)
  (values
    (paren-name    paren)
    (paren-token   paren)
    (paren-start-x paren)
    (paren-start-y paren)
    (paren-end-x   paren)
    (paren-end-y   paren)))


(define (show-paren obj port)
  (try
    (let ((token (paren-token obj)))
      (display (if token token #\_) port)
      (let ((inner-span (paren-inner obj)))
        (when (span? inner-span)
          (span-iterate inner-span
            (lambda (i inner)
              (unless (fxzero? i)
                (display #\space port))
              (show-paren inner port)))))
      (display (close-token-for token) port))
    (catch (condition)
      (display condition port))))

(define (debugf-paren obj)
  (try
    (debugf "debugf-paren token ~s, ok? ~s, start-x ~s, start-y ~s, end-x ~s, end-y ~s, inner ~s\n"
      (paren-token obj) (paren-ok? obj) (paren-start-x obj) (paren-start-y obj)
      (paren-end-x obj) (paren-end-y obj) (paren-inner obj))
    (catch (condition)
      (display condition (current-output-port)))))

(define (close-token-for token)
  (case token
    ((#\() #\)) ((#\[) #\]) ((#\{) #\})
    ((#\") #\") ((#\') #\') ((#\`) #\`)
    ((#\|) #\|) ((#\#) #\#) (else #\_)))

(define (is-paren-char? ch)
  (let ((vec '#(#\( #\) #\[ #\] #\{ #\} #\" #\' #\` #\| #\#)))
    (do ((i 0 (fx1+ i))
         (n (vector-length vec)))
        ((or (fx>=? i n) (eqv? ch (vector-ref vec i))) (fx<? i n)))))


;; customize how "paren" objects are printed
(record-writer (record-type-descriptor paren)
  (lambda (obj port writer)
    (display "#<paren " port)
    (show-paren obj port)
    (display ">" port)))


) ; close library
