#include "main.h"

void define_hash_iterator(void) {
  eval("(begin\n"
       "  ;;; return #t if argument is an hash-iterator, otherwise return #f\n"
       "  (define hash-iterator?)\n"
       "  \n"
       "  \n"
       "  ;;; return hash-iterator to first element in hashtable\n"
       "  (define hash-iterator-first)\n"
       "  \n"
       "  \n"
       "  ;;; modify hash-iterator in place to point to next hashtable element\n"
       "  ;;; return #t if more elements are available, otherwise return #f\n"
       "  (define hash-iterator-next!)\n"
       "  \n"
       "  \n"
       "  ;;; return hashtable element (key . val) corresponding to current position\n"
       "  ;;; of hash-iterator, or '() if end of hashtable is reached\n"
       "  ;;;\n"
       "  ;;; setting the cdr of returned element propagates back to the hashtable,\n"
       "  ;;; i.e. it is equivalent to setting the value associated to key in the hashtable\n"
       "  ;;;\n"
       "  ;;; NEVER set or modify in any way the car of returned element!\n"
       "  (define hash-iterator-cell))\n");

  eval("(let ()\n"
       "\n"
       ";;; hashtable-types.ss\n"
       ";;; Copyright 1984-2017 Cisco Systems, Inc.\n"
       ";;; \n"
       ";;; Licensed under the Apache License, Version 2.0 (the \"License\");\n"
       ";;; you may not use this file except in compliance with the License.\n"
       ";;; You may obtain a copy of the License at\n"
       ";;; \n"
       ";;; http://www.apache.org/licenses/LICENSE-2.0\n"
       ";;; \n"
       ";;; Unless required by applicable law or agreed to in writing, software\n"
       ";;; distributed under the License is distributed on an \"AS IS\" BASIS,\n"
       ";;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
       ";;; See the License for the specific language governing permissions and\n"
       ";;; limitations under the License.\n"
       "\n"
       "(define-record-type (hashtable make-xht xht?)\n"
       "  (fields (immutable type xht-type) (immutable mutable? xht-mutable?))\n"
       "  (nongenerative #{hashtable bu811z2onf9o6tfc-0}))\n"
       "\n"
       "(define-record-type ht\n"
       "  (parent hashtable)\n"
       "  (fields (mutable vec) (mutable minlen) (mutable size))\n"
       "  (nongenerative #{ht bu811z2onf9o6tfc-6}))\n"
       "\n"
       "(define-record-type eq-ht\n"
       "  (parent ht)\n"
       "  (fields (immutable subtype)) ; eq-hashtable-subtype-{normal,weak,ephemeron}\n"
       "  (nongenerative #{eq-ht icguu8mlhm1y7ywsairxck-0})\n"
       "  (sealed #t))\n"
       "\n"
       "(define-record-type symbol-ht\n"
       "  (parent ht)\n"
       "  (fields (immutable equiv?))\n"
       "  (nongenerative #{symbol-ht bu811z2onf9o6tfc-8})\n"
       "  (sealed #t))\n"
       "\n"
       "(define-record-type gen-ht\n"
       "  (parent ht)\n"
       "  (fields (immutable hash) (immutable equiv?))\n"
       "  (nongenerative #{gen-ht bu811z2onf9o6tfc-7})\n"
       "  (sealed #t))\n"
       "\n"
       "(define-record-type eqv-ht\n"
       "  (parent hashtable)\n"
       "  (fields (immutable eqht) (immutable genht))\n"
       "  (nongenerative #{eqv-ht bu811z2onf9o6tfc-4})\n"
       "  (sealed #t))\n"
       "\n"
       ";;; \n"
       ";;; end of hashtable-types.ss\n"
       ";;; \n"
       ";;; The following code belongs to schemesh\n"
       ";;; \n"
       "\n"
       /**
        * FIXME: eqv hashtables contain two inner hashtables:
        * one for keys comparable with eq, and one for all other keys.
        * We must retrieve both vectors from them and iterate on both
        */
       "(define-record-type %hash-iterator\n"
       "  (fields (mutable index) (mutable bucket) (immutable vec)))\n"
       "\n"
       "(define (hash-bucket-valid? bucket)\n"
       "  (or (pair? bucket) (#3%$tlc? bucket)))\n"
       "\n"
       "(define (hash-bucket-keyval bucket)\n"
       "  (cond\n"
       "    ((pair? bucket)    (car bucket))\n"
       "    ((#3%$tlc? bucket) (#3%$tlc-keyval bucket))\n"
       "    (else             '())))\n"
       "\n"
       "(define (hash-bucket-next bucket)\n"
       "  (cond\n"
       "    ((pair? bucket)    (cdr bucket))\n"
       "    ((#3%$tlc? bucket) (#3%$tlc-next bucket))\n"
       "    (else             '())))\n"
       "\n"
       "(set! hash-iterator?\n"
       "  (lambda (iter)\n"
       "    (%hash-iterator? iter)))\n"
       "\n"
       "(set! hash-iterator-cell\n"
       "  (lambda (iter)\n"
       "    (hash-bucket-keyval (%hash-iterator-bucket iter))))\n"
       "\n"
       "(set! hash-iterator-first\n"
       "  (lambda (h)\n"
       "    (let* ((vec (ht-vec h))\n"
       "           (iter (make-%hash-iterator -1 '() vec)))\n"
       "      (if (fx=? 0 (hashtable-size h))\n"
       "        ; hashtable is empty, seek to its end\n"
       "        (%hash-iterator-index-set! iter (vector-length vec))\n"
       "        ; hashtable is not empty, seek to first bucket\n"
       "        (hash-iterator-next! iter))\n"
       "      iter)))\n"
       "\n"
       "(set! hash-iterator-next!\n"
       "  (lambda (iter)\n"
       "    (let* ((index  (%hash-iterator-index iter))\n"
       "           (bucket (%hash-iterator-bucket iter))\n"
       "           (vec    (%hash-iterator-vec   iter))\n"
       "           (vend   (vector-length vec)))\n"
       "      (set! bucket (hash-bucket-next bucket))\n"
       "      (do ()\n"
       "        ((or (hash-bucket-valid? bucket) (fx>= index vend)))\n"
       "        (set! index (fx1+ index))\n"
       "        (when (fx< index vend)\n"
       "          (set! bucket (vector-ref vec index))))\n"
       "      (%hash-iterator-index-set!  iter index)\n"
       "      (%hash-iterator-bucket-set! iter bucket)\n"
       "      (hash-bucket-valid? bucket))))\n"
       "\n"
       ")\n");
}
